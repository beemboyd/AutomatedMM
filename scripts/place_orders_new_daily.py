#!/usr/bin/env python
"""
Place Orders New Daily Script

This script is responsible for placing new CNC (delivery) orders based on signal files
generated by scan_market_daily.py. It takes the output from scan_market_daily.py
and places limit orders with the current price as the buy price.

Features:
- Places CNC (delivery) orders for daily trading signals
- Sets stop loss based on the SL values from the scan results
- Uses the current market price for limit orders
- Respects ticker cooldown period (ticker_cooldown_hours in config.ini)
- Default cooldown is 2 hours if not specified in config

Created: 2025-05-08
"""

import os
import sys
import json
import logging
import argparse
import pandas as pd
import requests
from datetime import datetime

# Add parent directory to path so we can import modules
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Import trading system modules
from config import get_config
from data_handler import get_data_handler
from order_manager import get_order_manager
from state_manager import get_state_manager
from trading_logic import get_trading_logic

# Set up logging
def setup_logging():
    config = get_config()
    log_dir = config.get('System', 'log_dir')
    log_level = config.get('System', 'log_level')
    
    os.makedirs(log_dir, exist_ok=True)
    
    # Create place_orders_new_daily.log in the log directory
    log_file = os.path.join(log_dir, 'place_orders_new_daily.log')
    
    # Configure logging
    log_format = '%(asctime)s - %(levelname)s - %(message)s'
    logging.basicConfig(
        level=getattr(logging, log_level.upper()),
        format=log_format,
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )
    
    logger = logging.getLogger()
    logger.info(f"Logging initialized at level {log_level}")
    
    return logger

def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description="Place CNC orders based on daily scan results")
    parser.add_argument(
        "-f", "--file", 
        help="Path to the daily scan Excel file (from scan_market_daily.py)"
    )
    parser.add_argument(
        "-m", "--max-positions", 
        type=int,
        help="Maximum number of positions to take"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose logging"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Perform a dry run without placing actual orders"
    )
    return parser.parse_args()

def find_latest_daily_scan_file():
    """Find the latest Excel file generated by scan_market_daily.py"""
    logger = logging.getLogger()
    daily_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "Daily")
    
    if not os.path.exists(daily_dir):
        logger.error(f"Daily directory not found: {daily_dir}")
        return None
    
    scan_files = [f for f in os.listdir(daily_dir) if f.startswith("Custom_Scanner_") and f.endswith(".xlsx")]
    
    if not scan_files:
        logger.error("No scan result files found in Daily directory")
        return None
    
    # Sort by file modification time (most recent first)
    scan_files.sort(key=lambda x: os.path.getmtime(os.path.join(daily_dir, x)), reverse=True)
    latest_file = os.path.join(daily_dir, scan_files[0])
    
    logger.info(f"Found latest scan result file: {latest_file}")
    return latest_file

def get_current_market_price(ticker, order_manager):
    """Get the current market price for a ticker"""
    # Get the logger
    logger = logging.getLogger()
    
    try:
        # Check if get_ltp method exists
        if hasattr(order_manager, 'get_ltp'):
            return order_manager.get_ltp(ticker)
        
        # If not, directly use Kite API
        ltp_data = order_manager.kite.ltp(f"NSE:{ticker}")
        key = f"NSE:{ticker}"
        
        if ltp_data and key in ltp_data:
            current_price = ltp_data[key]["last_price"]
            logger.debug(f"Ticker {ticker} - Current Price: {current_price}")
            return current_price
        else:
            logger.warning(f"No LTP data for {ticker}.")
            return None
    except Exception as e:
        logger.error(f"Error getting market price for {ticker}: {e}")
        return None

def place_daily_orders(order_manager, scan_file, max_positions, dry_run=False):
    """Place new CNC orders based on daily scan results"""
    logger = logging.getLogger()
    
    # Load the scan file
    if not os.path.exists(scan_file):
        logger.error(f"Scan file {scan_file} not found")
        return
    
    try:
        # Read the Excel file
        df = pd.read_excel(scan_file, engine="openpyxl")
        if df.empty:
            logger.info("No trading opportunities found in scan file")
            return
        
        logger.info(f"Found {len(df)} potential trading opportunities in scan file")
        
        # Get configuration
        config = get_config()
        
        # Take only the top N opportunities based on Slope (already sorted in file)
        if max_positions and max_positions < len(df):
            logger.info(f"Limiting to top {max_positions} opportunities based on Slope")
            opportunities_df = df.head(max_positions)
        else:
            opportunities_df = df
        
        # Get state manager for position tracking
        state_manager = get_state_manager()
        positions = state_manager.get_positions_by_type("CNC")
        
        # Convert to expected format
        previous_state = {}
        for ticker, data in positions.items():
            previous_state[ticker] = {
                "quantity": data.get("quantity", 0),
                "timestamp": datetime.fromisoformat(data.get("timestamp", datetime.now().isoformat())),
                "sl_price": data.get("sl_price", 0)
            }
        logger.info(f"Previous CNC positions: {list(previous_state.keys())}")
        
        # Fetch current portfolio positions and pending orders
        # Since get_cnc_positions doesn't exist, we'll filter CNC positions from state manager
        existing_positions = {}
        try:
            # Check actual portfolio positions via Kite API
            positions_data = order_manager.kite.positions()
            net_positions = positions_data.get("net", [])
            
            for pos in net_positions:
                # Process only CNC positions for the configured exchange
                if pos.get("exchange", "") == order_manager.exchange and pos.get("product", "") == "CNC":
                    qty = pos.get("quantity", 0)
                    ticker = pos.get("tradingsymbol", "").strip().upper()
                    purchase_price = pos.get("average_price", 0)
                    
                    if qty > 0:
                        existing_positions[ticker] = {"quantity": qty, "purchase_price": purchase_price}
            
            logger.info(f"Found {len(existing_positions)} CNC positions from broker")
        except Exception as e:
            logger.warning(f"Error fetching CNC positions from broker: {e}. Using state manager positions instead.")
            # Fallback to state manager
            all_positions = state_manager.get_positions_by_type("CNC")
            for ticker, data in all_positions.items():
                if data.get("quantity", 0) > 0:
                    existing_positions[ticker] = {"quantity": data.get("quantity", 0)}
        
        pending_orders = order_manager.get_pending_orders()
        
        logger.info(f"Current CNC positions: {list(existing_positions.keys())}")
        logger.info(f"Pending orders: {list(pending_orders)}")
        
        # Determine new positions to open
        now = datetime.now()
        tickers_to_buy = {}
        
        for idx, row in opportunities_df.iterrows():
            ticker = str(row.get("Ticker", "")).strip().upper()
            if not ticker:
                continue
                
            # Get position size, SL and TP
            pos_size = row.get("PosSize", 0)
            if pd.isna(pos_size) or pos_size <= 0:
                logger.warning(f"Invalid position size for {ticker}: {pos_size}")
                continue
                
            sl_price = row.get("SL", 0)
            if pd.isna(sl_price) or sl_price <= 0:
                logger.warning(f"Invalid stop loss price for {ticker}: {sl_price}")
                continue
                
            tp_price = row.get("TP", 0)
            if pd.isna(tp_price) or tp_price <= 0:
                logger.warning(f"Invalid target price for {ticker}: {tp_price}")
                continue
            
            # Check cooldown period
            if ticker in previous_state:
                last_time = previous_state[ticker]["timestamp"]
                cooldown_hours = config.get_float('Trading', 'ticker_cooldown_hours', fallback=2.0)
                cooldown_seconds = cooldown_hours * 3600
                if (now - last_time).total_seconds() < cooldown_seconds:
                    logger.info(f"Order for {ticker} skipped as last order was placed less than {cooldown_hours} hours ago at {last_time}.")
                    continue
                    
            # Skip if already in portfolio or has pending orders
            if ticker in existing_positions or ticker in pending_orders:
                logger.info(f"Skipping {ticker} as it already exists in portfolio or has pending orders")
                continue
                
            # Get current market price
            current_price = get_current_market_price(ticker, order_manager)
            if not current_price:
                logger.warning(f"Could not get current market price for {ticker}, skipping")
                continue
            
            # Calculate quantity based on position size
            quantity = max(1, int(round(pos_size)))
            
            # Add to buy list with all info
            tickers_to_buy[ticker] = {
                "quantity": quantity,
                "limit_price": current_price,
                "sl_price": sl_price,
                "tp_price": tp_price
            }
        
        logger.info(f"New positions to open: {tickers_to_buy}")
        
        if dry_run:
            logger.info("DRY RUN: Would place the following orders:")
            for ticker, info in tickers_to_buy.items():
                logger.info(f"  {ticker}: Qty={info['quantity']}, Price={info['limit_price']}, SL={info['sl_price']}, TP={info['tp_price']}")
            return
        
        # Place buy orders with limit price
        orders_placed = {}
        for ticker, info in tickers_to_buy.items():
            qty = info["quantity"]
            price = info["limit_price"]
            sl_price = info["sl_price"]
            
            # Place CNC limit order
            logger.info(f"Placing CNC LIMIT BUY order for {ticker}: Qty={qty}, Price={price}, SL={sl_price}")
            
            # Implement place_cnc_order directly in our script since it doesn't exist in order_manager
            try:
                # Create order payload
                payload = {
                    "tradingsymbol": ticker,
                    "exchange": order_manager.exchange,
                    "transaction_type": "BUY",
                    "order_type": "LIMIT",
                    "quantity": qty,
                    "product": "CNC",  # Always use CNC for delivery
                    "validity": "DAY",
                    "price": price
                }
                
                logger.info(f"Sending CNC order with payload: {payload}")
                response = requests.post(order_manager.order_url, headers=order_manager.headers, data=payload)
                
                if response.ok:
                    # Try to extract order details
                    response_data = response.json()
                    order_id = response_data.get("data", {}).get("order_id", "unknown")
                    logger.info(f"CNC order placed successfully for {ticker}: {response.text}")
                    success = True
                else:
                    logger.error(f"Failed to place CNC order for {ticker}: {response.status_code} {response.text}")
                    success = False
            except Exception as e:
                logger.exception(f"Exception placing CNC order for {ticker}: {e}")
                success = False
            
            if success:
                logger.info(f"Successfully placed order for {ticker}")
                orders_placed[ticker] = {
                    "quantity": qty,
                    "timestamp": datetime.now().isoformat(),
                    "limit_price": price,
                    "sl_price": sl_price,
                    "tp_price": info["tp_price"]
                }
                
                # Place stop loss order
                logger.info(f"Setting stop loss for {ticker} at {sl_price}")
                try:
                    # Check if order manager has the method
                    if hasattr(order_manager, 'place_gtt_sl_order'):
                        order_manager.place_gtt_sl_order(ticker, qty, sl_price)
                    else:
                        # Implement GTT order placement directly
                        # First get current price for trigger value
                        current_price = get_current_market_price(ticker, order_manager)
                        if not current_price:
                            logger.warning(f"Could not get current price for {ticker} SL order, using limit price")
                            current_price = price
                        
                        # Create GTT payload
                        condition = {
                            "exchange": order_manager.exchange,
                            "tradingsymbol": ticker,
                            "trigger_values": [sl_price],
                            "last_price": current_price
                        }
                        
                        orders = [{
                            "exchange": order_manager.exchange,
                            "tradingsymbol": ticker,
                            "transaction_type": "SELL",
                            "quantity": qty,
                            "order_type": "LIMIT",
                            "product": "CNC",  # Use CNC for delivery
                            "price": sl_price
                        }]
                        
                        payload = {
                            "type": "single",  # for a single trigger GTT
                            "condition": json.dumps(condition),
                            "orders": json.dumps(orders)
                        }
                        
                        logger.info(f"Placing GTT SL order for {ticker} with payload: {payload}")
                        response = requests.post(order_manager.gtt_url, headers=order_manager.headers, data=payload)
                        
                        if response.ok:
                            response_data = response.json()
                            trigger_id = response_data.get("data", {}).get("trigger_id")
                            if trigger_id:
                                # Update the state manager with GTT info (if available)
                                if hasattr(state_manager, 'add_gtt'):
                                    state_manager.add_gtt(ticker, trigger_id, sl_price)
                                logger.info(f"GTT SL order placed successfully for {ticker} with trigger_id {trigger_id}")
                            else:
                                logger.warning(f"GTT order placed but no trigger_id found in response: {response.text}")
                        else:
                            logger.error(f"Failed to place GTT SL order for {ticker}: {response.status_code} {response.text}")
                    
                    logger.info(f"Successfully set stop loss for {ticker}")
                except Exception as sl_ex:
                    logger.error(f"Error setting stop loss for {ticker}: {sl_ex}")
            else:
                logger.error(f"Failed to place order for {ticker}")
        
        # Update state manager with new positions
        if orders_placed:
            for ticker, info in orders_placed.items():
                state_manager.add_position(
                    ticker, 
                    "CNC", 
                    "LONG", 
                    info["quantity"], 
                    info["limit_price"], 
                    info["sl_price"]
                )
            
            logger.info(f"Placed {len(orders_placed)} new CNC orders with stop losses")
        else:
            logger.info("No new CNC orders placed")
            
    except Exception as e:
        logger.exception(f"Error placing CNC orders: {e}")

def main():
    # Parse command line arguments
    args = parse_args()
    
    # Initialize logging
    logger = setup_logging()
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Log start of execution
    logger.info(f"===== CNC Order Placement Started at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} =====")
    
    # Get order manager
    order_manager = get_order_manager()
    
    # Get max positions from args or config
    config = get_config()
    max_positions = args.max_positions or config.get_int('Trading', 'max_cnc_positions', fallback=5)
    
    # Get scan file path
    scan_file = args.file
    if not scan_file:
        logger.info("Scan file not specified, looking for latest file...")
        scan_file = find_latest_daily_scan_file()
        
    if not scan_file:
        logger.error("No scan file found or specified. Exiting.")
        return
        
    logger.info(f"Using scan file: {scan_file}")
    
    # Place orders
    try:
        place_daily_orders(order_manager, scan_file, max_positions, args.dry_run)
    except Exception as e:
        logger.exception(f"Error during order placement: {e}")
    
    # Log end of execution
    logger.info(f"===== CNC Order Placement Completed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} =====\n")

if __name__ == "__main__":
    main()